# BOF ON ANY ARCH

This script automates the process of setting up the environment for binary exploitation on foreign architectures.

## Requirements

- python3 and pwntools
    
    I use `python3.9`, you can install pwntools with pip :
    
    `pip3.9 install pwntools`
    
- Other
    
    For the other dependencies, just run the program, it will help you.
    

## Program

```python
  ######################
 #### Dependencies ####
######################
import shutil
import sys
import os, time, subprocess

def check_dependencies():
    missing = []
    libs_path={}
    required_cmds = [
        ("qemu-aarch64", "QEMU for ARM64", "sudo apt-get install qemu-aarch64"),
        ("qemu-arm", "QEMU for ARM (32-bit)", "sudo apt-get install qemu-arm"),
        ("qemu-i386", "QEMU for x86 (i386)", "sudo apt-get install qemu-i386"),
        ("qemu-x86_64", "QEMU for x86_64 (amd64)", "sudo apt-get install qemu-x86_64"),
        ("qemu-mips", "QEMU for MIPS", "sudo apt-get install qemu-mips"),
        ("qemu-riscv64", "QEMU for RISC-V 64-bit", "sudo apt-get install qemu-riscv64"),
        ("gdb-multiarch", "GDB Multiarch", "sudo apt-get install gdb-multiarch"),
        ("tmux", "tmux terminal", "sudo apt-get install tmux"),
    ]
    required_libs = [
        ("arm", "arm-linux-gnueabihf", "sudo apt-get install libc6-dev-armhf-cross"),
        ("aarch64", "aarch64-linux-gnu",    "sudo apt-get install libc6-dev-arm64-cross"),
        ("mips", "mips-linux-gnu",       "sudo apt-get install libc6-dev-mips-cross"),
        ("riscv64", "riscv64-linux-gnu",    "sudo apt-get install libc6-dev-riscv64-cross"),
        ("i386", "i386-linux-gnu",       "sudo apt-get install libc6-dev-i386-cross"),
        ("amd64", "x86_64-linux-gnu",     "sudo apt-get install libc6-dev-amd64-cross"),
    ]
    for util in required_cmds:
        if shutil.which(util[0]) is None:
            missing.append(util)
    for lib in required_libs:
        usr_path = os.path.join("/usr",lib[1])
        usr_lib_path = os.path.join("/usr/lib",lib[1])
        if os.path.isdir(usr_path):
            libs_path[lib[0]]=usr_path
            print(f"{lib[0] } -> {usr_path}")
        elif os.path.isdir(usr_lib_path):
            libs_path[lib[0]]=usr_lib_path
            print(f"{lib[0] } -> {usr_lib_path}")
        else :
            missing.append(lib)
        
    if missing:
        dependencies_tips="\n".join([i[2] for i in missing])

        sys.exit("Missing required dependencies: " + ", ".join([i[1] for i in missing]) + "\nHow to install them ?\n"+dependencies_tips)
    else:
        print("All required dependencies are installed.")

        return libs_path

LIBS_PATH=check_dependencies()

  ##########################################
 ### Auto Arch pwntools based Debugger ####
##########################################

from pwn import *

# Binary config
BINARY = "./binaries/vuln_riscv64"  ################## <- change this parametter ##################
ELF_BINARY = ELF(BINARY)

# Set the architecture 
context.arch = ELF_BINARY.arch
context.binary = BINARY
log.info(f"=== Context\n> arch : {context.arch}\n> binary :{context.binary}")

# Setup for QEMU
mapping = {
    "arm":       "qemu-arm",
    "aarch64":   "qemu-aarch64",
    "mips":      "qemu-mips",
    "riscv64":   "qemu-riscv64",
    "i386":      "qemu-i386",
    "amd64":     "qemu-x86_64",
}
if context.arch not in mapping:
    log.info(f"[!] ERROR in qemu setup : {context.arch} not in mapping")
    exit(1)

QEMU = mapping[context.arch]
GDB_PORT = 1234

# Configure the terminal (use tmux for split view) -> see https://www.redhat.com/en/blog/introduction-tmux-linux
if "TMUX" not in os.environ:
    sys.exit("Error: Please run this script inside a tmux session.")
context.terminal = ["tmux", "splitw", "-h"]

# Start the binary inside QEMU using the appropriate lib path
quemu_start = [QEMU, "-g", str(GDB_PORT), "-L", LIBS_PATH[context.arch], BINARY]
p = process(quemu_start)
log.info(" ".join(quemu_start))
time.sleep(1)
log.info("Started QEMU process; waiting for gdb to attach...")

# GDB script to connect to QEMU

user_script=""""""

gdb_version = "gdb-multiarch"
# Attach gdb-multiarch
gdb_cmd = [
    f"{gdb_version} {BINARY} ",
    f"-ex 'set solib-search-path {LIBS_PATH[context.arch]}' ",
    f"-ex 'set architecture {context.arch}' ",
    f"-ex 'target remote localhost:{GDB_PORT}' ", 
    user_script                        
]
gdb_cmd_line = "".join(gdb_cmd)
subprocess.Popen(context.terminal + [gdb_cmd_line])
log.info(f"GDB debugger attached to {GDB_PORT} :\n$ " + "\n".join(gdb_cmd))
 
receive = p.recvuntil(b"What is your name ?",timeout=3600) # <- you must be waiting for something, or just do p.interactive()

```

Here are the common path for the versions of qemu :

- **x86:** `/usr/bin/qemu-i386`
- **x86_64:** `/usr/bin/qemu-x86_64`
- **ARM:**
    - 32‑bit: `/usr/bin/qemu-arm`
    - 64‑bit: `/usr/bin/qemu-aarch64`
- **MIPS:** `/usr/bin/qemu-mips`
- **RISC‑V:**
    - 32‑bit: `/usr/bin/qemu-riscv32`
    - 64‑bit: `/usr/bin/qemu--riscv64`
- Full list here
    
    ```python
    qemu-aarch64
    qemu-arm
    qemu-i386
    qemu-mips
    qemu-mips64
    qemu-mips64el
    qemu-mipsel
    qemu-riscv32
    qemu-riscv64
    qemu-x86_64
    ```
    
- Get a list of files on each arch
    
    ### Requirements
    
    ```bash
    sudo apt-get install gcc-multilib libc6-dev-i386
    sudo apt-get install gcc-arm-linux-gnueabi
    sudo apt-get install gcc-aarch64-linux-gnu
    sudo apt-get install gcc-mips-linux-gnu
    sudo apt-get install gcc-riscv64-linux-gnu
    sudo apt-get install mingw-w64
    
    ```
    
    ### Script
    
    ```bash
    #!/bin/bash
    
    SOURCE="hello_word.c"
    compile() {
        local compiler="$1"
        local flags="$2"
        local output="$3"
    
        if command -v "$compiler" &> /dev/null; then
            echo "Compiling for $output using $compiler..."
            "$compiler" $flags "$SOURCE" -o "$output"
            if [ $? -eq 0 ]; then
                echo "Successfully built $output"
            else
                echo "Failed to build $output"
            fi
        else
            echo "Compiler $compiler not found. Skipping $output."
        fi
    }
    
    compile gcc "-m32" "hello_word_x86"
    compile gcc "-m64" "hello_word_x86_64"
    compile arm-linux-gnueabi-gcc "" "hello_word_arm"
    compile aarch64-linux-gnu-gcc "" "hello_word_arm64"
    compile mips-linux-gnu-gcc "" "hello_word_mips"
    compile riscv64-linux-gnu-gcc "" "hello_word_riscv64"
    compile x86_64-w64-mingw32-gcc "" "hello_word_PE.exe"
    echo "Compilation finished."
    ```
    
    ### Result
    
    ```
    hello_word_arm
    hello_word_mips
    hello_word_PE.exe
    hello_word_riscv64
    hello_word_x86
    hello_word_x86_64
    ```
    

## What is context.arch depending on files ?

hello_word_arm → `arm` 

hello_word_arm64 → `aarch64` 

hello_word_mips → `mips`

~~hello_word_PE.exe~~

hello_word_riscv64 → `riscv64`

hello_word_x86 → `i386`

hello_word_x86_64 → `amd64`

---

## Errors

If you get errors linked to the **ld-linux.so.3** : `/lib/ld-linux.so.3: No such file or directory` 

→ `sudo apt-get install libc6-armhf-cross`

→ `sudo ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux.so.3`

→ `tree /usr/arm-linux-gnueabihf/lib`

→ `qemu-arm -g 1234 -L /usr/arm-linux-gnueabihf hello_word_arm`

When you give a path to qemu, it will try to retrieve libraries as if it was the real file system. So the libraries must be in DIR/lib/ path and you must give the DIR to qemu.